# 16946번: 벽 부수고 이동하기 4 - <img src="https://static.solved.ac/tier_small/14.svg" style="height:20px" /> Gold II

<!-- performance -->

<!-- 문제 제출 후 깃허브에 푸시를 했을 때 제출한 코드의 성능이 입력될 공간입니다.-->

<!-- end -->

## 문제

[문제 링크](https://boj.kr/16946)

<p>N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 한 칸에서 다른 칸으로 이동하려면, 두 칸이 인접해야 한다. 두 칸이 변을 공유할 때, 인접하다고 한다.</p>

<p>각각의 벽에 대해서 다음을 구해보려고 한다.</p>

<ul>
<li>벽을 부수고 이동할 수 있는 곳으로 변경한다.</li>
<li>그 위치에서 이동할 수 있는 칸의 개수를 세어본다.</li>
</ul>

<p>한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.</p>

## 입력

<p>첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다.</p>

## 출력

<p>맵의 형태로 정답을 출력한다. 원래 빈 칸인 곳은 0을 출력하고, 벽인&nbsp;곳은 이동할 수 있는 칸의 개수를 10으로 나눈 나머지를 출력한다.</p>

## 소스코드

[소스코드 보기](벽%20부수고%20이동하기%204.cpp)

## 풀이

1. 벽이 아닌 칸들을 대상으로 BFS 실행. 인접해 있는 빈칸이 얼마나 많은지 개수를 세며 분리집합을 이용해서 인접하게 붙어있는 칸들을 각각 그룹화.

2. 벽인 칸들을 대상으로 인접한 빈칸들을 모두 확인. 해당 빈칸들이 속해있는 그룹의 크기를 모두 더하면 벽을 부쉈을 때의 이동할 수 있는 칸의 개수가 됨.
단, 인접한 칸이 같은 그룹 내에 있을 경우는 두 그룹 모두 합이 되지 않도록 주의.